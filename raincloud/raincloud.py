import warnings
from logging import getLogger
from typing import Callable, Union, Iterable, Tuple, Sequence

import numpy as np
from matplotlib.axes import Axes
from matplotlib.colors import to_rgba
from pandas import DataFrame
from scipy import stats
import matplotlib as mpl
import matplotlib.pyplot as plt
import seaborn as sns
from seaborn.utils import iqr, remove_na
from seaborn.categorical import _CategoricalPlotter, _CategoricalScatterPlotter

__all__ = ["half_violinplot", "stripplot", "distplot"]

log = getLogger(__name__)


class _StripPlotter(_CategoricalScatterPlotter):
    """1-d scatterplot with categorical organization."""

    def __init__(
        self,
        x,
        y,
        hue,
        data,
        order,
        hue_order,
        jitter,
        dodge,
        orient,
        color,
        palette,
        width,
        move,
    ):
        """Initialize the plotter."""
        self.establish_variables(x, y, hue, data, orient, order, hue_order)
        self.establish_colors(color, palette, 1)

        # Set object attributes
        self.dodge = dodge
        self.width = width
        self.move = move

        if jitter == 1:  # Use a good default for `jitter = True`
            jlim = 0.1
        else:
            jlim = float(jitter)
        if self.hue_names is not None and dodge:
            jlim /= len(self.hue_names)
        self.jitterer = stats.uniform(-jlim, jlim * 2).rvs

    def draw_stripplot(self, ax, kws):
        """Draw the points onto `ax`."""
        # Set the default zorder to 2.1, so that the points
        # will be drawn on top of line elements (like in a boxplot)
        for i, group_data in enumerate(self.plot_data):
            if self.plot_hues is None or not self.dodge:

                if self.hue_names is None:
                    hue_mask = np.ones(group_data.size, np.bool)
                else:
                    hue_mask = np.array(
                        [h in self.hue_names for h in self.plot_hues[i]],
                        np.bool,
                    )
                    # Broken on older numpys
                    # hue_mask = np.in1d(self.plot_hues[i], self.hue_names)

                strip_data = group_data[hue_mask]

                # Plot the points in centered positions
                cat_pos = self.move + np.ones(strip_data.size) * i
                cat_pos += self.jitterer(len(strip_data))
                kws.update(c=self.point_colors[i][hue_mask])
                if self.orient == "v":
                    ax.scatter(cat_pos, strip_data, **kws)
                else:
                    ax.scatter(strip_data, cat_pos, **kws)

            else:
                offsets = self.hue_offsets
                for j, hue_level in enumerate(self.hue_names):
                    hue_mask = self.plot_hues[i] == hue_level
                    strip_data = group_data[hue_mask]

                    # Plot the points in centered positions
                    center = i + offsets[j]
                    cat_pos = self.move + np.ones(strip_data.size) * center
                    cat_pos += self.jitterer(len(strip_data))
                    kws.update(c=self.point_colors[i][hue_mask])
                    if self.orient == "v":
                        ax.scatter(cat_pos, strip_data, **kws)
                    else:
                        ax.scatter(strip_data, cat_pos, **kws)

    def plot(self, ax, kws):
        """Make the plot."""
        self.draw_stripplot(ax, kws)
        self.add_legend_data(ax)
        self.annotate_axes(ax)
        if self.orient == "h":
            ax.invert_yaxis()


class _Half_ViolinPlotter(_CategoricalPlotter):
    def __init__(
        self,
        x,
        y,
        hue,
        data,
        order,
        hue_order,
        bw,
        cut,
        scale,
        scale_hue,
        alpha,
        gridsize,
        width,
        inner,
        split,
        dodge,
        orient,
        linewidth,
        color,
        palette,
        saturation,
        offset,
    ):

        self.establish_variables(x, y, hue, data, orient, order, hue_order)
        self.establish_colors(color, palette, saturation)
        self.estimate_densities(bw, cut, scale, scale_hue, gridsize)

        self.gridsize = gridsize
        self.width = width
        self.dodge = dodge
        self.offset = offset
        self.alpha = alpha

        if inner is not None:
            if not any(
                [
                    inner.startswith("quart"),
                    inner.startswith("box"),
                    inner.startswith("stick"),
                    inner.startswith("point"),
                ]
            ):
                err = "Inner style '{}' not recognized".format(inner)
                raise ValueError(err)
        self.inner = inner

        if split and self.hue_names is not None and len(self.hue_names) < 2:
            msg = "There must be at least two hue levels to use `split`.'"
            raise ValueError(msg)
        self.split = split

        if linewidth is None:
            linewidth = mpl.rcParams["lines.linewidth"]
        self.linewidth = linewidth

    def estimate_densities(self, bw, cut, scale, scale_hue, gridsize):
        """Find the support and density for all of the data."""
        # Initialize data structures to keep track of plotting data
        if self.hue_names is None:
            support = []
            density = []
            counts = np.zeros(len(self.plot_data))
            max_density = np.zeros(len(self.plot_data))
        else:
            support = [[] for _ in self.plot_data]
            density = [[] for _ in self.plot_data]
            size = len(self.group_names), len(self.hue_names)
            counts = np.zeros(size)
            max_density = np.zeros(size)

        for i, group_data in enumerate(self.plot_data):

            # Option 1: we have a single level of grouping
            # --------------------------------------------

            if self.plot_hues is None:

                # Strip missing datapoints
                kde_data = remove_na(group_data)

                # Handle special case of no data at this level
                if kde_data.size == 0:
                    support.append(np.array([]))
                    density.append(np.array([1.]))
                    counts[i] = 0
                    max_density[i] = 0
                    continue

                # Handle special case of a single unique datapoint
                elif np.unique(kde_data).size == 1:
                    support.append(np.unique(kde_data))
                    density.append(np.array([1.]))
                    counts[i] = 1
                    max_density[i] = 0
                    continue

                # Fit the KDE and get the used bandwidth size
                kde, bw_used = self.fit_kde(kde_data, bw)

                # Determine the support grid and get the density over it
                support_i = self.kde_support(kde_data, bw_used, cut, gridsize)
                density_i = kde.evaluate(support_i)

                # Update the data structures with these results
                support.append(support_i)
                density.append(density_i)
                counts[i] = kde_data.size
                max_density[i] = density_i.max()

            # Option 2: we have nested grouping by a hue variable
            # ---------------------------------------------------

            else:
                for j, hue_level in enumerate(self.hue_names):

                    # Handle special case of no data at this category level
                    if not group_data.size:
                        support[i].append(np.array([]))
                        density[i].append(np.array([1.]))
                        counts[i, j] = 0
                        max_density[i, j] = 0
                        continue

                    # Select out the observations for this hue level
                    hue_mask = self.plot_hues[i] == hue_level

                    # Strip missing datapoints
                    kde_data = remove_na(group_data[hue_mask])

                    # Handle special case of no data at this level
                    if kde_data.size == 0:
                        support[i].append(np.array([]))
                        density[i].append(np.array([1.]))
                        counts[i, j] = 0
                        max_density[i, j] = 0
                        continue

                    # Handle special case of a single unique datapoint
                    elif np.unique(kde_data).size == 1:
                        support[i].append(np.unique(kde_data))
                        density[i].append(np.array([1.]))
                        counts[i, j] = 1
                        max_density[i, j] = 0
                        continue

                    # Fit the KDE and get the used bandwidth size
                    kde, bw_used = self.fit_kde(kde_data, bw)

                    # Determine the support grid and get the density over it
                    support_ij = self.kde_support(
                        kde_data, bw_used, cut, gridsize
                    )
                    density_ij = kde.evaluate(support_ij)

                    # Update the data structures with these results
                    support[i].append(support_ij)
                    density[i].append(density_ij)
                    counts[i, j] = kde_data.size
                    max_density[i, j] = density_ij.max()

        # Scale the height of the density curve.
        # For a violinplot the density is non-quantitative.
        # The objective here is to scale the curves relative to 1 so that
        # they can be multiplied by the width parameter during plotting.

        if scale == "area":
            self.scale_area(density, max_density, scale_hue)

        elif scale == "width":
            self.scale_width(density)

        elif scale == "count":
            self.scale_count(density, counts, scale_hue)

        else:
            raise ValueError("scale method '{}' not recognized".format(scale))

        # Set object attributes that will be used while plotting
        self.support = support
        self.density = density

    def fit_kde(self, x, bw):
        """Estimate a KDE for a vector of data with flexible bandwidth."""
        # Allow for the use of old scipy where `bw` is fixed
        try:
            kde = stats.gaussian_kde(x, bw)
        except TypeError:
            kde = stats.gaussian_kde(x)
            if bw != "scott":  # scipy default
                msg = (
                    "Ignoring bandwidth choice, "
                    "please upgrade scipy to use a different bandwidth."
                )
                warnings.warn(msg, UserWarning)

        # Extract the numeric bandwidth from the KDE object
        bw_used = kde.factor

        # At this point, bw will be a numeric scale factor.
        # To get the actual bandwidth of the kernel, we multiple by the
        # unbiased standard deviation of the data, which we will use
        # elsewhere to compute the range of the support.
        bw_used = bw_used * x.std(ddof=1)

        return kde, bw_used

    def kde_support(self, x, bw, cut, gridsize):
        """Define a grid of support for the violin."""
        support_min = x.min() - bw * cut
        support_max = x.max() + bw * cut
        return np.linspace(support_min, support_max, gridsize)

    def scale_area(self, density, max_density, scale_hue):
        """Scale the relative area under the KDE curve.
        This essentially preserves the "standard" KDE scaling, but the
        resulting maximum density will be 1 so that the curve can be
        properly multiplied by the violin width.
        """
        if self.hue_names is None:
            for d in density:
                if d.size > 1:
                    d /= max_density.max()
        else:
            for i, group in enumerate(density):
                for d in group:
                    if scale_hue:
                        max = max_density[i].max()
                    else:
                        max = max_density.max()
                    if d.size > 1:
                        d /= max

    def scale_width(self, density):
        """Scale each density curve to the same height."""
        if self.hue_names is None:
            for d in density:
                d /= d.max()
        else:
            for group in density:
                for d in group:
                    d /= d.max()

    def scale_count(self, density, counts, scale_hue):
        """Scale each density curve by the number of observations."""
        if self.hue_names is None:
            if counts.max() == 0:
                d = 0
            else:
                for count, d in zip(counts, density):
                    d /= d.max()
                    d *= count / counts.max()
        else:
            for i, group in enumerate(density):
                for j, d in enumerate(group):
                    if counts[i].max() == 0:
                        d = 0
                    else:
                        count = counts[i, j]
                        if scale_hue:
                            scaler = count / counts[i].max()
                        else:
                            scaler = count / counts.max()
                        d /= d.max()
                        d *= scaler

    @property
    def dwidth(self):

        if self.hue_names is None or not self.dodge:
            return self.width / 2
        elif self.split:
            return self.width / 2
        else:
            return self.width / (2 * len(self.hue_names))

    def draw_violins(self, ax):
        """Draw the violins onto `ax`."""
        fill_func = ax.fill_betweenx if self.orient == "v" else ax.fill_between
        for i, group_data in enumerate(self.plot_data):

            kws = dict(
                edgecolor=self.gray, linewidth=self.linewidth, alpha=self.alpha
            )

            # Option 1: we have a single level of grouping
            # --------------------------------------------

            if self.plot_hues is None:

                support, density = self.support[i], self.density[i]

                # Handle special case of no observations in this bin
                if support.size == 0:
                    continue

                # Handle special case of a single observation
                elif support.size == 1:
                    val = np.asscalar(support)
                    d = np.asscalar(density)
                    self.draw_single_observation(ax, i, val, d)
                    continue

                # Draw the violin for this group
                grid = np.ones(self.gridsize) * i
                fill_func(
                    support,
                    -self.offset + grid - density * self.dwidth,
                    -self.offset + grid,
                    facecolor=self.colors[i],
                    **kws,
                )

                # Draw the interior representation of the data
                if self.inner is None:
                    continue

                # Get a nan-free vector of datapoints
                violin_data = remove_na(group_data)

                # Draw box and whisker information
                if self.inner.startswith("box"):
                    self.draw_box_lines(ax, violin_data, support, density, i)

                # Draw quartile lines
                elif self.inner.startswith("quart"):
                    self.draw_quartiles(ax, violin_data, support, density, i)

                # Draw stick observations
                elif self.inner.startswith("stick"):
                    self.draw_stick_lines(ax, violin_data, support, density, i)

                # Draw point observations
                elif self.inner.startswith("point"):
                    self.draw_points(ax, violin_data, i)

            # Option 2: we have nested grouping by a hue variable
            # ---------------------------------------------------

            else:
                offsets = self.hue_offsets
                for j, hue_level in enumerate(self.hue_names):

                    support, density = self.support[i][j], self.density[i][j]
                    kws["facecolor"] = self.colors[j]

                    # Add legend data, but just for one set of violins
                    if not i:
                        self.add_legend_data(ax, self.colors[j], hue_level)

                    # Handle the special case where we have no observations
                    if support.size == 0:
                        continue

                    # Handle the special case where we have one observation
                    elif support.size == 1:
                        val = np.asscalar(support)
                        d = np.asscalar(density)
                        if self.split:
                            d = d / 2
                        at_group = i + offsets[j]
                        self.draw_single_observation(ax, at_group, val, d)
                        continue

                    # Option 2a: we are drawing a single split violin
                    # -----------------------------------------------

                    if self.split:

                        grid = np.ones(self.gridsize) * i
                        if j:
                            fill_func(
                                support,
                                -self.offset + grid - density * self.dwidth,
                                -self.offset + grid,
                                **kws,
                            )
                        else:
                            fill_func(
                                support,
                                -self.offset + grid - density * self.dwidth,
                                -self.offset + grid,
                                **kws,
                            )

                        # Draw the interior representation of the data
                        if self.inner is None:
                            continue

                        # Get a nan-free vector of datapoints
                        hue_mask = self.plot_hues[i] == hue_level
                        violin_data = remove_na(group_data[hue_mask])

                        # Draw quartile lines
                        if self.inner.startswith("quart"):
                            self.draw_quartiles(
                                ax,
                                violin_data,
                                support,
                                density,
                                i,
                                ["left", "right"][j],
                            )

                        # Draw stick observations
                        elif self.inner.startswith("stick"):
                            self.draw_stick_lines(
                                ax,
                                violin_data,
                                support,
                                density,
                                i,
                                ["left", "right"][j],
                            )

                        # The box and point interior plots are drawn for
                        # all data at the group level, so we just do that once
                        if not j:
                            continue

                        # Get the whole vector for this group level
                        violin_data = remove_na(group_data)

                        # Draw box and whisker information
                        if self.inner.startswith("box"):
                            self.draw_box_lines(
                                ax, violin_data, support, density, i
                            )

                        # Draw point observations
                        elif self.inner.startswith("point"):
                            self.draw_points(ax, violin_data, i)

                    # Option 2b: we are drawing full nested violins
                    # -----------------------------------------------

                    else:
                        grid = np.ones(self.gridsize) * (i + offsets[j])
                        fill_func(
                            support,
                            -self.offset + grid - density * self.dwidth,
                            -self.offset + grid,
                            **kws,
                        )

                        # Draw the interior representation
                        if self.inner is None:
                            continue

                        # Get a nan-free vector of datapoints
                        hue_mask = self.plot_hues[i] == hue_level
                        violin_data = remove_na(group_data[hue_mask])

                        # Draw box and whisker information
                        if self.inner.startswith("box"):
                            self.draw_box_lines(
                                ax,
                                violin_data,
                                support,
                                density,
                                i + offsets[j],
                            )

                        # Draw quartile lines
                        elif self.inner.startswith("quart"):
                            self.draw_quartiles(
                                ax,
                                violin_data,
                                support,
                                density,
                                i + offsets[j],
                            )

                        # Draw stick observations
                        elif self.inner.startswith("stick"):
                            self.draw_stick_lines(
                                ax,
                                violin_data,
                                support,
                                density,
                                i + offsets[j],
                            )

                        # Draw point observations
                        elif self.inner.startswith("point"):
                            self.draw_points(ax, violin_data, i + offsets[j])

    def draw_single_observation(self, ax, at_group, at_quant, density):
        """Draw a line to mark a single observation."""
        d_width = density * self.dwidth
        if self.orient == "v":
            ax.plot(
                [at_group - d_width, at_group + d_width],
                [at_quant, at_quant],
                color=self.gray,
                linewidth=self.linewidth,
            )
        else:
            ax.plot(
                [at_quant, at_quant],
                [at_group - d_width, at_group + d_width],
                color=self.gray,
                linewidth=self.linewidth,
            )

    def draw_box_lines(self, ax, data, support, density, center):
        """Draw boxplot information at center of the density."""
        # Compute the boxplot statistics
        q25, q50, q75 = np.percentile(data, [25, 50, 75])
        whisker_lim = 1.5 * iqr(data)
        h1 = np.min(data[data >= (q25 - whisker_lim)])
        h2 = np.max(data[data <= (q75 + whisker_lim)])

        # Draw a boxplot using lines and a point
        if self.orient == "v":
            ax.plot(
                [center, center],
                [h1, h2],
                linewidth=self.linewidth,
                color=self.gray,
            )
            ax.plot(
                [center, center],
                [q25, q75],
                linewidth=self.linewidth * 3,
                color=self.gray,
            )
            ax.scatter(
                center,
                q50,
                zorder=3,
                color="white",
                edgecolor=self.gray,
                s=np.square(self.linewidth * 2),
            )
        else:
            ax.plot(
                [h1, h2],
                [center, center],
                linewidth=self.linewidth,
                color=self.gray,
            )
            ax.plot(
                [q25, q75],
                [center, center],
                linewidth=self.linewidth * 3,
                color=self.gray,
            )
            ax.scatter(
                q50,
                center,
                zorder=3,
                color="white",
                edgecolor=self.gray,
                s=np.square(self.linewidth * 2),
            )

    def draw_quartiles(self, ax, data, support, density, center, split=False):
        """Draw the quartiles as lines at width of density."""
        q25, q50, q75 = np.percentile(data, [25, 50, 75])

        self.draw_to_density(
            ax,
            center,
            q25,
            support,
            density,
            split,
            linewidth=self.linewidth,
            dashes=[self.linewidth * 1.5] * 2,
        )
        self.draw_to_density(
            ax,
            center,
            q50,
            support,
            density,
            split,
            linewidth=self.linewidth,
            dashes=[self.linewidth * 3] * 2,
        )
        self.draw_to_density(
            ax,
            center,
            q75,
            support,
            density,
            split,
            linewidth=self.linewidth,
            dashes=[self.linewidth * 1.5] * 2,
        )

    def draw_points(self, ax, data, center):
        """Draw individual observations as points at middle of the violin."""
        kws = dict(
            s=np.square(self.linewidth * 2),
            color=self.gray,
            edgecolor=self.gray,
        )

        grid = np.ones(len(data)) * center

        if self.orient == "v":
            ax.scatter(grid, data, **kws)
        else:
            ax.scatter(data, grid, **kws)

    def draw_stick_lines(self, ax, data, support, density, center, split=False):
        """Draw individual observations as sticks at width of density."""
        for val in data:
            self.draw_to_density(
                ax,
                center,
                val,
                support,
                density,
                split,
                linewidth=self.linewidth * .5,
            )

    def draw_to_density(self, ax, center, val, support, density, split, **kws):
        """Draw a line orthogonal to the value axis at width of density."""
        idx = np.argmin(np.abs(support - val))
        width = self.dwidth * density[idx] * .99

        kws["color"] = self.gray

        if self.orient == "v":
            if split == "left":
                ax.plot([center - width, center], [val, val], **kws)
            elif split == "right":
                ax.plot([center, center + width], [val, val], **kws)
            else:
                ax.plot([center - width, center + width], [val, val], **kws)
        else:
            if split == "left":
                ax.plot([val, val], [center - width, center], **kws)
            elif split == "right":
                ax.plot([val, val], [center, center + width], **kws)
            else:
                ax.plot([val, val], [center - width, center + width], **kws)

    def plot(self, ax):
        """Make the violin plot."""
        self.draw_violins(ax)
        self.annotate_axes(ax)
        if self.orient == "h":
            ax.invert_yaxis()


def stripplot(
    x=None,
    y=None,
    hue=None,
    data=None,
    order=None,
    hue_order=None,
    jitter=True,
    dodge=False,
    orient=None,
    color=None,
    palette=None,
    move=0,
    size=5,
    edgecolor="gray",
    linewidth=0,
    ax=None,
    width=0.8,
    **kwargs,
):

    if "split" in kwargs:
        dodge = kwargs.pop("split")
        msg = "The `split` parameter has been renamed to `dodge`."
        warnings.warn(msg, UserWarning)

    plotter = _StripPlotter(
        x,
        y,
        hue,
        data,
        order,
        hue_order,
        jitter,
        dodge,
        orient,
        color,
        palette,
        width,
        move,
    )
    if ax is None:
        ax = plt.gca()

    kwargs.setdefault("zorder", 3)
    size = kwargs.get("s", size)
    if linewidth is None:
        linewidth = size / 10
    if edgecolor == "gray":
        edgecolor = plotter.gray
    kwargs.update(dict(s=size ** 2, edgecolor=edgecolor, linewidth=linewidth))

    plotter.plot(ax, kwargs)
    return ax


def half_violinplot(
    x=None,
    y=None,
    hue=None,
    data=None,
    order=None,
    hue_order=None,
    bw="scott",
    cut=2,
    scale="area",
    scale_hue=True,
    alpha=1,
    gridsize=500,
    width=0.8,
    inner="box",
    split=False,
    dodge=True,
    orient=None,
    linewidth=None,
    color=None,
    palette=None,
    saturation=0.75,
    ax=None,
    offset=0.15,
    **kwargs,
):

    plotter = _Half_ViolinPlotter(
        x,
        y,
        hue,
        data,
        order,
        hue_order,
        bw,
        cut,
        scale,
        scale_hue,
        alpha,
        gridsize,
        width,
        inner,
        split,
        dodge,
        orient,
        linewidth,
        color,
        palette,
        saturation,
        offset,
    )

    if ax is None:
        ax = plt.gca()

    plotter.plot(ax)
    return ax


def distplot(
    x: Union[Iterable, np.ndarray, str] = None,
    y: Union[Iterable, np.ndarray, str] = None,
    hue=None,
    data: DataFrame = None,
    orient: str = "h",
    width_kde: float = 0.7,
    width_box: float = 0.08,
    palette: Union[None, str, Sequence] = "Set2",
    bw: Union[str, float, Callable] = 0.2,
    linewidth: float = 1,
    cut=0.,
    scale="area",
    jitter: float = 1,
    move: float = 0.,
    ms: float = 3,
    alpha_dot: float = 1,
    alpha_kde: float = 0.8,
    box_edge_color="#444444",
    offset=None,
    ax: Axes = None,
    figsize: Tuple[float, float] = (10, 4),
    pointplot: bool = False,
    dodge: bool = False,
    showfliers: bool = False,
    showcaps: bool = True,
    boxplot: bool = True,
    dotplot: bool = True,
    kdeplot: bool = True,
) -> Axes:
    """
    Plot distribution of the given data. `x`, `y`, `hue` and `data` as in
    standard Seaborn plots.

    (Except that 'x' will always be the data on the horizontal axis).

    palette: Plotting colours. See:
        >> https://seaborn.pydata.org/generated/seaborn.color_palette.html
    bw: Bandwidth of the kernel density estimates. Either "scott", "silverman",
        a scalar, or a function. See `scipy.stats.gaussian_kde`
    hue: Second category to split by.
    orient: Vertical if "v" (default), horizontal if "h"
    ms: Dot size for the strip-plots (i.e. the scatterplots / jittered
        dotplots).
    alpha_box: alpha of the face color of the main box of the boxplot.
        Ignored when `hue` is not None.
    """

    if ax is None:
        f, ax = plt.subplots(figsize=figsize)
    if offset is None:
        offset = max(width_box / 1.8, .15) + .05
    n_plots = 3
    split = False

    if hue is None:
        box_palette = None
        box_color = box_edge_color
        box_fc = "none"  # transparent
    else:
        box_palette = palette
        box_fc = None
        box_color = None

    if kdeplot:
        ax = half_violinplot(
            x=x,
            y=y,
            hue=hue,
            data=data,
            orient=orient,
            width=width_kde,
            alpha=alpha_kde,
            inner=None,
            palette=palette,
            bw=bw,
            linewidth=linewidth,
            cut=cut,
            scale=scale,
            split=split,
            offset=offset,
        )

    if boxplot:
        ax = sns.boxplot(
            x=x,
            y=y,
            hue=hue,
            data=data,
            orient=orient,
            width=width_box,
            showcaps=showcaps,
            showfliers=showfliers,
            dodge=dodge,
            color=box_color,
            palette=box_palette,
            saturation=1,
            boxprops=dict(zorder=10, edgecolor=box_edge_color, facecolor=box_fc),
            medianprops=dict(
                zorder=11, color=box_edge_color, solid_capstyle="butt"
            ),
            whiskerprops=dict(
                linewidth=2, zorder=10, color=box_edge_color, solid_capstyle="butt"
            ),
            capprops=dict(
                linewidth=2, zorder=10, color=box_edge_color, solid_capstyle="butt"
            ),
        )

    # jittered dotplot / 1D scatterplot:
    if dotplot:
        ax = stripplot(
            x=x,
            y=y,
            hue=hue,
            data=data,
            orient=orient,
            palette=palette,
            move=move,
            edgecolor="white",
            size=ms,
            alpha=alpha_dot,
            jitter=jitter,
            zorder=1,
            dodge=dodge,
            width=width_box,
        )

    if pointplot:
        n_plots = 4
        if not hue is None:
            ax = sns.pointplot(
                x=x,
                y=y,
                hue=hue,
                data=data,
                orient=orient,
                dodge=width_box / 2.,
                capsize=0.,
                errwidth=0.,
                palette=palette,
                zorder=20,
            )
        else:
            ax = sns.pointplot(
                x=x,
                y=y,
                hue=hue,
                data=data,
                color="red",
                orient=orient,
                dodge=width_box / 2.,
                capsize=0.,
                errwidth=0.,
                zorder=20,
            )

    # Prune the legend, add legend title
    if not hue is None:
        handles, labels = ax.get_legend_handles_labels()
        _ = plt.legend(
            handles[0 : len(labels) // n_plots],
            labels[0 : len(labels) // n_plots],
            bbox_to_anchor=(1.05, 1),
            loc=2,
            borderaxespad=0.,
            title=str(hue),
        )  # , title_fontsize = 25)

    # Adjust the ylim to fit (if needed)
    if orient == "h":
        ylim = list(ax.get_ylim())
        ylim[-1] -= (width_box + width_kde) / 4.
        _ = ax.set_ylim(ylim)
    elif orient == "v":
        xlim = list(ax.get_xlim())
        xlim[-1] -= (width_box + width_kde) / 4.
        _ = ax.set_xlim(xlim)

    # Make sure grid is plotted _below_ the data.
    ax.set_axisbelow(True)

    return ax
